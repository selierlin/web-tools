<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>文本对比</title>
    <style>
        :root {
            --neon-blue: #00d2ff;
            --neon-purple: #9d50bb;
            --neon-green: #00ff88;
            --neon-red: #ff0055;
            --bg-dark: #0a0c10;
            --panel-bg: rgba(16, 20, 28, 0.84);
            --card-bg: rgba(255, 255, 255, 0.03);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'PingFang SC', 'Microsoft YaHei', 'Fira Code', monospace;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: var(--bg-dark);
            height: 100vh;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            overflow: hidden;
            color: #e2e8f0;
            padding-top: 20px;
        }

        body::before {
            content: "";
            position: absolute;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle at center, #1a2a6c, #b21f1f, #fdbb2d);
            background-size: cover;
            animation: flow 20s infinite alternate;
            z-index: -1;
            opacity: 0.15;
        }

        @keyframes flow {
            0% { transform: translate(-25%, -25%) rotate(0deg); }
            100% { transform: translate(0%, 0%) rotate(10deg); }
        }

        .container {
            width: 95vw;
            height: 88vh;
            background: var(--panel-bg);
            backdrop-filter: blur(18px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .container::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--neon-blue), var(--neon-purple), transparent);
        }

        .tool-header {
            padding: 14px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.03);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            flex-wrap: wrap;
            gap: 8px;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            min-width: 0;
        }

        .tool-title {
            font-size: 22px;
            font-weight: 800;
            letter-spacing: 1px;
            background: linear-gradient(to right, var(--neon-blue), #fff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            white-space: nowrap;
        }

        .header-summary {
            display: none;
            align-items: center;
            flex-wrap: wrap;
            gap: 6px;
        }

        .header-summary.visible {
            display: flex;
        }

        .metric-chip {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(255, 255, 255, 0.03);
            color: #9ab5d5;
            font-size: 12px;
            line-height: 1;
        }

        .metric-chip strong {
            color: #e2e8f0;
            font-size: 13px;
        }

        .btn-group {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        button, select, input[type="text"] {
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.16);
            background: rgba(255, 255, 255, 0.05);
            color: #e2e8f0;
            font-size: 14px;
            padding: 7px 11px;
            outline: none;
            transition: all 0.3s ease;
        }

        button {
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-weight: 700;
            transition: transform 0.2s, filter 0.2s, box-shadow 0.3s ease;
        }

        button:hover {
            filter: brightness(1.15);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
        }

        button:active {
            transform: translateY(1px);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--neon-blue), var(--neon-purple));
            border: none;
            color: #fff;
            box-shadow: 0 0 14px rgba(0, 210, 255, 0.35);
        }

        .btn-primary:hover {
            box-shadow: 0 0 20px rgba(0, 210, 255, 0.5);
        }

        .btn-danger {
            background: rgba(255, 0, 85, 0.16);
            border-color: rgba(255, 0, 85, 0.38);
        }

        .btn-danger:hover {
            background: rgba(255, 0, 85, 0.25);
            box-shadow: 0 0 10px rgba(255, 0, 85, 0.3);
        }

        input[type="text"]:focus, select:focus {
            border-color: var(--neon-blue);
            box-shadow: 0 0 10px rgba(0, 210, 255, 0.2);
        }

        .control-panel {
            padding: 10px 14px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            background: rgba(0, 0, 0, 0.16);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }

        .mode-switch {
            display: inline-flex;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .mode-btn {
            border: none;
            border-radius: 0;
            background: rgba(255, 255, 255, 0.05);
            padding: 7px 12px;
            font-size: 14px;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, rgba(0, 210, 255, 0.35), rgba(157, 80, 187, 0.35));
            color: #fff;
        }

        .option-chip {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.14);
            background: rgba(255, 255, 255, 0.03);
            font-size: 14px;
            color: #cbd5e1;
            user-select: none;
        }

        .option-chip input {
            accent-color: var(--neon-blue);
        }

        .progress {
            margin-left: auto;
            font-size: 14px;
            color: #9cc8ff;
            min-height: 18px;
        }

        .compare-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .text-panel {
            flex: 1;
            display: flex;
            background: rgba(0, 0, 0, 0.15);
            position: relative;
            min-width: 0;
        }

        .text-panel:first-child {
            border-right: 1px solid rgba(255, 255, 255, 0.08);
        }

        .drop-mask {
            position: absolute;
            inset: 0;
            border: 2px dashed rgba(0, 210, 255, 0.65);
            background: rgba(0, 210, 255, 0.08);
            color: #cdefff;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            z-index: 8;
        }

        .text-panel.drag-over .drop-mask {
            display: flex;
        }

        .line-numbers {
            width: 45px;
            padding-top: 20px;
            background: rgba(0, 0, 0, 0.2);
            color: #4b5563;
            font-size: 13px;
            text-align: center;
            border-right: 1px solid rgba(255, 255, 255, 0.05);
            overflow: hidden;
            user-select: none;
        }

        .line-num {
            height: 22px;
            line-height: 22px;
        }

        .text-editor {
            flex: 1;
            padding: 16px 0;
            overflow: auto;
            transition: all 0.3s ease;
        }

        textarea, .editable-div {
            width: 100%;
            height: 100%;
            padding: 0 12px;
            background: transparent;
            border: none;
            outline: none;
            color: #cbd5e1;
            font-size: 15px;
            line-height: 22px;
            white-space: pre;
            tab-size: 4;
            resize: none;
            transition: all 0.3s ease;
        }

        textarea:focus {
            color: #e2e8f0;
        }

        .text-line {
            padding: 0 12px;
            min-height: 22px;
            border-left: 3px solid transparent;
            transition: all 0.2s ease;
        }

        .text-line:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .diff-added {
            background: rgba(0, 255, 136, 0.08);
            color: var(--neon-green);
            border-left-color: var(--neon-green);
            display: block;
            transition: all 0.3s ease;
        }

        .diff-added:hover {
            background: rgba(0, 255, 136, 0.12);
        }

        .diff-removed {
            background: rgba(255, 0, 85, 0.08);
            color: var(--neon-red);
            border-left-color: var(--neon-red);
            display: block;
            transition: all 0.3s ease;
        }

        .diff-removed:hover {
            background: rgba(255, 0, 85, 0.12);
        }

        .result-section {
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.18);
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 10px;
            max-height: 33vh;
            overflow: hidden;
        }

        .result-card {
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.02);
            display: flex;
            flex-direction: column;
            min-height: 0;
            transition: all 0.3s ease;
        }

        .result-card:hover {
            border-color: rgba(255, 255, 255, 0.15);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transform: translateY(-2px);
        }

        .result-card.hidden {
            display: none;
        }

        .result-header {
            padding: 10px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            background: rgba(255, 255, 255, 0.03);
        }

        .result-title {
            font-size: 14px;
            color: #d5e8ff;
            font-weight: 700;
        }

        .result-count {
            margin-left: auto;
            color: #9ab5d5;
            font-size: 13px;
            background: rgba(255, 255, 255, 0.05);
            padding: 2px 8px;
            border-radius: 12px;
        }

        .result-actions {
            display: flex;
            gap: 4px;
        }

        .result-actions button {
            padding: 4px 7px;
            font-size: 12px;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .result-actions button:hover {
            transform: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .result-body {
            position: relative;
            overflow: auto;
            flex: 1;
            font-size: 14px;
            line-height: 20px;
            color: #dbeafe;
            background: rgba(255, 255, 255, 0.01);
            transition: all 0.3s ease;
        }

        .result-body:hover {
            background: rgba(255, 255, 255, 0.02);
        }

        .virtual-top,
        .virtual-bottom {
            width: 100%;
        }

        .virtual-items {
            width: 100%;
        }

        .result-item {
            min-height: 20px;
            padding: 0 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.04);
        }

        .item-no {
            width: 38px;
            color: #7f9bbc;
            text-align: right;
            flex-shrink: 0;
            user-select: none;
        }

        .item-text {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }

        .result-empty {
            color: #64748b;
            padding: 10px;
            font-size: 14px;
        }

        mark {
            background: rgba(253, 224, 71, 0.5);
            color: #1f2937;
            padding: 0;
        }

        .char-diff-removed {
            background: rgba(255, 0, 85, 0.3);
            color: var(--neon-red);
            padding: 0 2px;
            border-radius: 2px;
        }

        .char-diff-added {
            background: rgba(0, 255, 136, 0.3);
            color: var(--neon-green);
            padding: 0 2px;
            border-radius: 2px;
        }

        @media (max-width: 900px) {
            body {
                padding: 0;
            }

            .container {
                width: 100vw;
                height: 100vh;
                border-radius: 0;
            }

            .tool-title {
                font-size: 18px;
            }

            .compare-content {
                flex-direction: column;
            }

            .text-panel:first-child {
                border-right: none;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }

            .line-numbers {
                width: 35px;
            }

            .metric-chip {
                font-size: 11px;
                padding: 3px 7px;
            }

            .metric-chip strong {
                font-size: 12px;
            }

            .result-section {
                grid-template-columns: 1fr;
                max-height: 34vh;
            }

            .progress {
                margin-left: 0;
                width: 100%;
            }
        }

        ::-webkit-scrollbar {
            width: 5px;
            height: 5px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.16);
            border-radius: 10px;
        }
    </style>
</head>
<body>
<div class="container">
    <header class="tool-header">
        <div class="header-left">
            <div class="tool-title">文本对比 v2.0</div>
        </div>
        <div class="btn-group">
            <div class="header-summary" id="summaryBar">
                <span class="metric-chip">左侧 <strong id="metricATotal">0</strong></span>
                <span class="metric-chip">右侧 <strong id="metricBTotal">0</strong></span>
                <span class="metric-chip">相同 <strong id="metricSame">0</strong></span>
                <span class="metric-chip">左多 <strong id="metricAMore">0</strong></span>
                <span class="metric-chip">右多 <strong id="metricBMore">0</strong></span>
                <span class="metric-chip">相似度 <strong id="metricSimilarity">0%</strong></span>
            </div>
            <button id="clearBtn" class="btn-danger">清空</button>
            <button id="compareBtn" class="btn-primary">执行对比</button>
            <button id="backToEditBtn" style="display: none;">返回编辑</button>
        </div>
    </header>

    <section class="control-panel">
        <div class="control-group">
            <span>比较模式</span>
            <div class="mode-switch">
                <button class="mode-btn active" data-mode="line" id="modeLine">逐行比较</button>
                <button class="mode-btn" data-mode="set" id="modeSet">集合比较</button>
                <button class="mode-btn" data-mode="json" id="modeJson">JSON比较</button>
            </div>
        </div>

        <div class="control-group json-options" style="display: none;">
            <label class="option-chip"><input type="checkbox" id="optJsonSort" checked> JSON排序</label>
            <label class="option-chip"><input type="checkbox" id="optJsonFormat" checked> JSON格式化</label>
        </div>

        <div class="control-group text-options">
            <span>输入拆分</span>
            <select id="parseMode">
                <option value="line">按行</option>
                <option value="column">按列</option>
            </select>
            <select id="delimiterSelect">
                <option value="auto">自动识别分隔符</option>
                <option value="newline">换行</option>
                <option value="comma">逗号</option>
                <option value="tab">制表符</option>
            </select>
        </div>

        <div class="control-group text-options">
            <label class="option-chip"><input type="checkbox" id="optTrim"> 忽略首尾空格</label>
            <label class="option-chip"><input type="checkbox" id="optCase"> 忽略大小写</label>
            <label class="option-chip"><input type="checkbox" id="optEmpty"> 忽略空行</label>
            <label class="option-chip"><input type="checkbox" id="optDedupe"> 去重后比较</label>
            <label class="option-chip"><input type="checkbox" id="optSort"> 排序后比较</label>
        </div>

        <div class="control-group">
            <input type="text" id="searchInput" placeholder="搜索结果并高亮">
        </div>

        <div class="progress" id="progressText"></div>
    </section>

    <main class="compare-content">
        <div class="text-panel" id="leftPanel">
            <div class="drop-mask">拖拽文件到左侧区域</div>
            <div class="line-numbers" id="leftLineNumbers"></div>
            <div class="text-editor" id="leftTextEditor">
                <textarea id="leftText" placeholder="// 左侧内容：支持拖拽文件或粘贴"></textarea>
            </div>
        </div>
        <div class="text-panel" id="rightPanel">
            <div class="drop-mask">拖拽文件到右侧区域</div>
            <div class="line-numbers" id="rightLineNumbers"></div>
            <div class="text-editor" id="rightTextEditor">
                <textarea id="rightText" placeholder="// 右侧内容：支持拖拽文件或粘贴"></textarea>
            </div>
        </div>
    </main>

    <section class="result-section" id="resultSection">
        <article class="result-card" data-group="aMore">
            <div class="result-header">
                <span class="result-title">仅在左侧</span>
                <span class="result-count" id="aMoreCount">0 条</span>
                <div class="result-actions">
                    <button data-action="copy" data-group="aMore">复制</button>
                    <button data-action="txt" data-group="aMore">TXT</button>
                    <button data-action="csv" data-group="aMore">CSV</button>
                    <button data-action="focus" data-group="aMore">仅看</button>
                </div>
            </div>
            <div class="result-body" id="aMoreBody"></div>
        </article>

        <article class="result-card" data-group="bMore">
            <div class="result-header">
                <span class="result-title">仅在右侧</span>
                <span class="result-count" id="bMoreCount">0 条</span>
                <div class="result-actions">
                    <button data-action="copy" data-group="bMore">复制</button>
                    <button data-action="txt" data-group="bMore">TXT</button>
                    <button data-action="csv" data-group="bMore">CSV</button>
                    <button data-action="focus" data-group="bMore">仅看</button>
                </div>
            </div>
            <div class="result-body" id="bMoreBody"></div>
        </article>

        <article class="result-card" data-group="same">
            <div class="result-header">
                <span class="result-title">左侧与右侧共有</span>
                <span class="result-count" id="sameCount">0 条</span>
                <div class="result-actions">
                    <button data-action="copy" data-group="same">复制</button>
                    <button data-action="txt" data-group="same">TXT</button>
                    <button data-action="csv" data-group="same">CSV</button>
                    <button data-action="focus" data-group="same">仅看</button>
                </div>
            </div>
            <div class="result-body" id="sameBody"></div>
        </article>
    </section>
</div>

<script>
    const leftText = document.getElementById('leftText');
    const rightText = document.getElementById('rightText');
    const leftLineNumbers = document.getElementById('leftLineNumbers');
    const rightLineNumbers = document.getElementById('rightLineNumbers');
    const leftTextEditor = document.getElementById('leftTextEditor');
    const rightTextEditor = document.getElementById('rightTextEditor');
    const leftPanel = document.getElementById('leftPanel');
    const rightPanel = document.getElementById('rightPanel');

    const compareBtn = document.getElementById('compareBtn');
    const clearBtn = document.getElementById('clearBtn');
    const backToEditBtn = document.getElementById('backToEditBtn');
    const progressText = document.getElementById('progressText');
    const resultSection = document.getElementById('resultSection');
    const summaryBar = document.getElementById('summaryBar');

    const metricATotal = document.getElementById('metricATotal');
    const metricBTotal = document.getElementById('metricBTotal');
    const metricSame = document.getElementById('metricSame');
    const metricAMore = document.getElementById('metricAMore');
    const metricBMore = document.getElementById('metricBMore');
    const metricSimilarity = document.getElementById('metricSimilarity');

    const parseMode = document.getElementById('parseMode');
    const delimiterSelect = document.getElementById('delimiterSelect');

    const optTrim = document.getElementById('optTrim');
    const optCase = document.getElementById('optCase');
    const optEmpty = document.getElementById('optEmpty');
    const optDedupe = document.getElementById('optDedupe');
    const optSort = document.getElementById('optSort');
    const optJsonSort = document.getElementById('optJsonSort');
    const optJsonFormat = document.getElementById('optJsonFormat');
    const jsonOptions = document.querySelector('.json-options');

    const searchInput = document.getElementById('searchInput');
    const modeButtons = Array.from(document.querySelectorAll('.mode-btn'));

    const groupMeta = {
        aMore: { body: document.getElementById('aMoreBody'), count: document.getElementById('aMoreCount'), empty: '左侧中没有仅左侧存在的数据。' },
        bMore: { body: document.getElementById('bMoreBody'), count: document.getElementById('bMoreCount'), empty: '右侧中没有仅右侧存在的数据。' },
        same: { body: document.getElementById('sameBody'), count: document.getElementById('sameCount'), empty: '左侧与右侧没有共同数据。' }
    };

    let isReplaced = { left: false, right: false };

    const state = {
        mode: 'line',
        filter: 'all',
        search: '',
        result: { aMore: [], bMore: [], same: [] }
    }

    class VirtualList {
        constructor(container, emptyText) {
            this.container = container;
            this.emptyText = emptyText;
            this.items = [];
            this.filtered = [];
            this.rowHeight = 20;
            this.top = document.createElement('div');
            this.mid = document.createElement('div');
            this.bottom = document.createElement('div');
            this.top.className = 'virtual-top';
            this.mid.className = 'virtual-items';
            this.bottom.className = 'virtual-bottom';
            container.innerHTML = '';
            container.append(this.top, this.mid, this.bottom);
            
            // 使用节流优化滚动事件
            this.container.addEventListener('scroll', throttle(() => {
                // 使用requestAnimationFrame优化渲染
                requestAnimationFrame(() => this.render());
            }, 16));
        }

        setItems(items) {
            this.items = items;
            this.applyFilter(state.search);
        }

        applyFilter(term) {
            if (!term) {
                this.filtered = this.items;
            } else {
                const q = term.toLowerCase();
                this.filtered = this.items.filter(v => v.toLowerCase().includes(q));
            }
            this.container.scrollTop = 0;
            this.render();
        }

        render() {
            const total = this.filtered.length;
            if (!total) {
                this.top.style.height = '0px';
                this.bottom.style.height = '0px';
                this.mid.innerHTML = `<div class="result-empty">${this.emptyText}</div>`;
                return;
            }

            const viewHeight = this.container.clientHeight || 220;
            const visibleCount = Math.ceil(viewHeight / this.rowHeight) + 8;
            const start = Math.max(0, Math.floor(this.container.scrollTop / this.rowHeight) - 4);
            const end = Math.min(total, start + visibleCount);

            this.top.style.height = `${start * this.rowHeight}px`;
            this.bottom.style.height = `${(total - end) * this.rowHeight}px`;

            // 使用DocumentFragment批量处理DOM更新，减少重排和重绘
            const fragment = document.createDocumentFragment();
            
            for (let i = start; i < end; i++) {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'result-item';
                
                const noSpan = document.createElement('span');
                noSpan.className = 'item-no';
                noSpan.textContent = i + 1;
                
                const textSpan = document.createElement('span');
                textSpan.className = 'item-text';
                textSpan.innerHTML = highlightText(escapeHtml(this.filtered[i]), state.search);
                
                itemDiv.appendChild(noSpan);
                itemDiv.appendChild(textSpan);
                fragment.appendChild(itemDiv);
            }
            
            // 清空并添加新内容
            this.mid.innerHTML = '';
            this.mid.appendChild(fragment);
        }
    }

    const virtualLists = {
        aMore: new VirtualList(groupMeta.aMore.body, groupMeta.aMore.empty),
        bMore: new VirtualList(groupMeta.bMore.body, groupMeta.bMore.empty),
        same: new VirtualList(groupMeta.same.body, groupMeta.same.empty)
    };

    function escapeHtml(text) {
        return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function highlightText(safeText, query) {
        if (!query) return safeText;
        const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const reg = new RegExp(escapedQuery, 'ig');
        return safeText.replace(reg, m => `<mark>${m}</mark>`);
    }

    function detectDelimiter(text) {
        const n = (text.match(/\n/g) || []).length;
        const t = (text.match(/\t/g) || []).length;
        const c = (text.match(/,/g) || []).length;
        if (n >= t && n >= c && n > 0) return 'newline';
        if (t >= c && t > 0) return 'tab';
        if (c > 0) return 'comma';
        return 'newline';
    }

    function normalizeToken(token) {
        let v = token;
        if (optTrim.checked) v = v.trim();
        if (optCase.checked) v = v.toLowerCase();
        return v;
    }

    function tokenize(text) {
        const mode = parseMode.value;
        let tokens;

        if (mode === 'line') {
            tokens = text.split(/\r?\n/);
        } else {
            let delimiter = delimiterSelect.value;
            if (delimiter === 'auto') {
                delimiter = detectDelimiter(text);
            }
            if (delimiter === 'newline') tokens = text.split(/\r?\n/);
            if (delimiter === 'comma') tokens = text.split(',');
            if (delimiter === 'tab') tokens = text.split('\t');
        }

        tokens = tokens.map(normalizeToken);
        if (optEmpty.checked) tokens = tokens.filter(Boolean);
        if (optDedupe.checked) {
            const seen = new Set();
            tokens = tokens.filter(v => {
                if (seen.has(v)) return false;
                seen.add(v);
                return true;
            });
        }
        if (optSort.checked) {
            tokens.sort();
        }
        return tokens;
    }

    function syncLineNumbers() {
        const lVal = isReplaced.left ? document.getElementById('leftTextEditable')?.innerText || '' : leftText.value;
        const rVal = isReplaced.right ? document.getElementById('rightTextEditable')?.innerText || '' : rightText.value;
        renderLines(leftLineNumbers, Math.max(1, lVal.split('\n').length));
        renderLines(rightLineNumbers, Math.max(1, rVal.split('\n').length));
    }

    function renderLines(target, count) {
        // 使用DocumentFragment批量处理DOM更新，减少重排和重绘
        const fragment = document.createDocumentFragment();
        
        for (let i = 0; i < count; i++) {
            const lineDiv = document.createElement('div');
            lineDiv.className = 'line-num';
            lineDiv.textContent = i + 1;
            fragment.appendChild(lineDiv);
        }
        
        target.innerHTML = '';
        target.appendChild(fragment);
    }

    function setProgress(text) {
        progressText.textContent = text || '';
    }

    function setSummaryVisible(visible) {
        summaryBar.classList.toggle('visible', visible);
    }

    function resetEditorsToTextarea() {
        if (isReplaced.left) {
            leftTextEditor.innerHTML = '';
            leftTextEditor.appendChild(leftText);
            // 清除原始内容标记，确保下次能够重新保存
            delete leftText.dataset.originalContent;
            isReplaced.left = false;
        }
        if (isReplaced.right) {
            rightTextEditor.innerHTML = '';
            rightTextEditor.appendChild(rightText);
            // 清除原始内容标记，确保下次能够重新保存
            delete rightText.dataset.originalContent;
            isReplaced.right = false;
        }
        // 隐藏返回编辑按钮
        backToEditBtn.style.display = 'none';
        // 重新绑定滚动事件
        bindScrollEvents();
    }

    function renderDiffPanels(leftLines, rightLines) {
        // 智能匹配左右两侧的行，处理行顺序不同或行数量不同的情况
        const leftCount = leftLines.length;
        const rightCount = rightLines.length;
        
        // 创建左右两侧行的映射，用于快速查找匹配的行
        const leftMap = new Map();
        for (let i = 0; i < leftCount; i++) {
            const line = leftLines[i];
            if (line) {
                leftMap.set(line, i);
            }
        }
        
        const rightMap = new Map();
        for (let i = 0; i < rightCount; i++) {
            const line = rightLines[i];
            if (line) {
                rightMap.set(line, i);
            }
        }
        
        let leftHtml = '';
        let rightHtml = '';
        let i = 0, j = 0;
        
        while (i < leftCount || j < rightCount) {
            if (i >= leftCount) {
                const rOnly = rightLines[j] || '';
                leftHtml += `<div class="text-line"></div>`;
                rightHtml += `<div class="text-line diff-added">${escapeHtml(rOnly)}</div>`;
                j++;
                continue;
            }
            if (j >= rightCount) {
                const lOnly = leftLines[i] || '';
                leftHtml += `<div class="text-line diff-removed">${escapeHtml(lOnly)}</div>`;
                rightHtml += `<div class="text-line"></div>`;
                i++;
                continue;
            }

            const l = i < leftCount ? leftLines[i] : '';
            const r = j < rightCount ? rightLines[j] : '';
            
            if (l === r) {
                // 两行相同，不高亮
                leftHtml += `<div class="text-line">${escapeHtml(l)}</div>`;
                rightHtml += `<div class="text-line">${escapeHtml(r)}</div>`;
                i++;
                j++;
            } else {
                // 尝试查找右侧是否有与当前左侧行匹配的行
                if (rightMap.has(l)) {
                    // 右侧有与当前左侧行匹配的行，说明左侧行在右侧的后面，右侧当前行是新增的
                    rightHtml += `<div class="text-line diff-added">${escapeHtml(r)}</div>`;
                    leftHtml += `<div class="text-line"></div>`;
                    j++;
                } 
                // 尝试查找左侧是否有与当前右侧行匹配的行
                else if (leftMap.has(r)) {
                    // 左侧有与当前右侧行匹配的行，说明右侧行在左侧的后面，左侧当前行是删除的
                    leftHtml += `<div class="text-line diff-removed">${escapeHtml(l)}</div>`;
                    rightHtml += `<div class="text-line"></div>`;
                    i++;
                } else {
                    // 两行确实不同，尝试解析键值对格式
                    const leftMatch = l.match(/^("[^"]+"):\s*(.*)$/);
                    const rightMatch = r.match(/^("[^"]+"):\s*(.*)$/);
                    
                    if (leftMatch && rightMatch && leftMatch[1] === rightMatch[1]) {
                        // 如果是相同键的键值对，只高亮值的差异
                        const key = leftMatch[1];
                        const leftValue = leftMatch[2];
                        const rightValue = rightMatch[2];
                        
                        const charDiff = highlightCharsDiff(leftValue, rightValue);
                        leftHtml += `<div class="text-line ${l ? 'diff-removed' : ''}">${escapeHtml(key)}: ${charDiff.old}</div>`;
                        rightHtml += `<div class="text-line ${r ? 'diff-added' : ''}">${escapeHtml(key)}: ${charDiff.new}</div>`;
                    } else {
                        // 否则使用字符级差异高亮
                        const charDiff = highlightCharsDiff(l, r);
                        leftHtml += `<div class="text-line ${l ? 'diff-removed' : ''}">${charDiff.old}</div>`;
                        rightHtml += `<div class="text-line ${r ? 'diff-added' : ''}">${charDiff.new}</div>`;
                    }
                    i++;
                    j++;
                }
            }
        }

        leftTextEditor.innerHTML = `<div id="leftTextEditable" class="editable-div" contenteditable="false" ondblclick="resetEditorsToTextarea()">${leftHtml}</div>`;
        rightTextEditor.innerHTML = `<div id="rightTextEditable" class="editable-div" contenteditable="false" ondblclick="resetEditorsToTextarea()">${rightHtml}</div>`;
        isReplaced.left = true;
        isReplaced.right = true;
        backToEditBtn.style.display = 'inline-flex';
        // 重新绑定滚动事件
        bindScrollEvents();
    }

    function toCountMap(items) {
        const map = new Map();
        for (const item of items) {
            map.set(item, (map.get(item) || 0) + 1);
        }
        return map;
    }

    function mapToExpandedArray(map) {
        const arr = [];
        for (const [item, count] of map.entries()) {
            for (let i = 0; i < count; i++) arr.push(item);
        }
        return arr;
    }

    function sortObject(obj) {
        if (obj === null || typeof obj !== 'object') return obj;
        if (Array.isArray(obj)) return obj.map(sortObject);
        const sorted = {};
        Object.keys(obj).sort().forEach(key => {
            sorted[key] = sortObject(obj[key]);
        });
        return sorted;
    }

    function alignJSON(leftObj, rightObj) {
        // 获取所有唯一键并排序
        const leftKeys = Object.keys(leftObj || {});
        const rightKeys = Object.keys(rightObj || {});
        const allKeys = [...new Set([...leftKeys, ...rightKeys])].sort();

        // 为左右两侧创建对齐的对象
        const alignedLeft = {};
        const alignedRight = {};

        for (const key of allKeys) {
            // 只重排已有字段，不为缺失字段补 null，避免对比后出现“凭空新增”的行
            if (Object.prototype.hasOwnProperty.call(leftObj, key)) {
                alignedLeft[key] = leftObj[key];
            }
            if (Object.prototype.hasOwnProperty.call(rightObj, key)) {
                alignedRight[key] = rightObj[key];
            }
        }

        return { left: alignedLeft, right: alignedRight };
    }

    function formatJSON(jsonStr, sort = false) {
        try {
            let parsed = JSON.parse(jsonStr);
            if (sort) {
                parsed = sortObject(parsed);
            }
            return JSON.stringify(parsed, null, 2);
        } catch (e) {
            return jsonStr;
        }
    }

    function formatAlignedJSON(obj) {
        // 确保按照排序后的顺序输出字段
        const sortedObj = {};
        Object.keys(obj).sort().forEach(key => {
            sortedObj[key] = obj[key];
        });
        return JSON.stringify(sortedObj, null, 2);
    }

    function parseJSON(jsonStr, sort = false) {
        try {
            let parsed = JSON.parse(jsonStr);
            if (sort) {
                parsed = sortObject(parsed);
            }
            return parsed;
        } catch (e) {
            // 尝试添加外层大括号后再次解析
            try {
                let cleanedJson = jsonStr.trim();
                // 移除末尾的逗号
                if (cleanedJson.endsWith(',')) {
                    cleanedJson = cleanedJson.slice(0, -1);
                }
                const wrappedJson = `{${cleanedJson}}`;
                let parsed = JSON.parse(wrappedJson);
                if (sort) {
                    parsed = sortObject(parsed);
                }
                return parsed;
            } catch (e2) {
                return null;
            }
        }
    }

    function highlightCharsDiff(oldStr, newStr) {
        if (oldStr === newStr) {
            return { old: escapeHtml(oldStr), new: escapeHtml(newStr) };
        }

        // 简单的字符级差异高亮
        let oldHtml = '';
        let newHtml = '';
        let i = 0, j = 0;

        while (i < oldStr.length || j < newStr.length) {
            if (i < oldStr.length && j < newStr.length && oldStr[i] === newStr[j]) {
                oldHtml += escapeHtml(oldStr[i]);
                newHtml += escapeHtml(newStr[j]);
                i++;
                j++;
            } else {
                // 查找最长公共子序列
                let maxLen = 0;
                let maxI = i;
                let maxJ = j;

                for (let x = i; x < oldStr.length; x++) {
                    for (let y = j; y < newStr.length; y++) {
                        let len = 0;
                        while (x + len < oldStr.length && y + len < newStr.length && oldStr[x + len] === newStr[y + len]) {
                            len++;
                        }
                        if (len > maxLen) {
                            maxLen = len;
                            maxI = x;
                            maxJ = y;
                        }
                    }
                }

                if (maxLen > 0) {
                    // 高亮差异部分
                    if (i < maxI) {
                        oldHtml += `<mark class="char-diff-removed">${escapeHtml(oldStr.substring(i, maxI))}</mark>`;
                    }
                    if (j < maxJ) {
                        newHtml += `<mark class="char-diff-added">${escapeHtml(newStr.substring(j, maxJ))}</mark>`;
                    }
                    // 添加相同部分
                    oldHtml += escapeHtml(oldStr.substring(maxI, maxI + maxLen));
                    newHtml += escapeHtml(newStr.substring(maxJ, maxJ + maxLen));
                    i = maxI + maxLen;
                    j = maxJ + maxLen;
                } else {
                    // 剩余部分全为差异
                    if (i < oldStr.length) {
                        oldHtml += `<mark class="char-diff-removed">${escapeHtml(oldStr.substring(i))}</mark>`;
                    }
                    if (j < newStr.length) {
                        newHtml += `<mark class="char-diff-added">${escapeHtml(newStr.substring(j))}</mark>`;
                    }
                    break;
                }

            }

        }

        return { old: oldHtml, new: newHtml };
    }

    function highlightJSONDiff(left, right) {
        // 智能匹配左右两侧的行，处理行顺序不同或行数量不同的情况
        const leftLines = left.split('\n');
        const rightLines = right.split('\n');
        const leftCount = leftLines.length;
        const rightCount = rightLines.length;
        
        // 创建左右两侧行的映射，用于快速查找匹配的行
        const leftMap = new Map();
        for (let i = 0; i < leftCount; i++) {
            const line = leftLines[i];
            if (line) {
                leftMap.set(line, i);
            }
        }
        
        const rightMap = new Map();
        for (let i = 0; i < rightCount; i++) {
            const line = rightLines[i];
            if (line) {
                rightMap.set(line, i);
            }
        }
        
        let leftHtml = '';
        let rightHtml = '';
        let i = 0, j = 0;
        
        while (i < leftCount || j < rightCount) {
            if (i >= leftCount) {
                const rOnly = rightLines[j] || '';
                leftHtml += `<div class="text-line"></div>`;
                rightHtml += `<div class="text-line diff-added">${escapeHtml(rOnly)}</div>`;
                j++;
                continue;
            }
            if (j >= rightCount) {
                const lOnly = leftLines[i] || '';
                leftHtml += `<div class="text-line diff-removed">${escapeHtml(lOnly)}</div>`;
                rightHtml += `<div class="text-line"></div>`;
                i++;
                continue;
            }

            const l = i < leftCount ? leftLines[i] : '';
            const r = j < rightCount ? rightLines[j] : '';
            
            if (l === r) {
                // 两行相同，不高亮
                leftHtml += `<div class="text-line">${escapeHtml(l)}</div>`;
                rightHtml += `<div class="text-line">${escapeHtml(r)}</div>`;
                i++;
                j++;
            } else {
                // 尝试查找右侧是否有与当前左侧行匹配的行
                if (rightMap.has(l)) {
                    // 右侧有与当前左侧行匹配的行，说明左侧行在右侧的后面，右侧当前行是新增的
                    rightHtml += `<div class="text-line diff-added">${escapeHtml(r)}</div>`;
                    leftHtml += `<div class="text-line"></div>`;
                    j++;
                } 
                // 尝试查找左侧是否有与当前右侧行匹配的行
                else if (leftMap.has(r)) {
                    // 左侧有与当前右侧行匹配的行，说明右侧行在左侧的后面，左侧当前行是删除的
                    leftHtml += `<div class="text-line diff-removed">${escapeHtml(l)}</div>`;
                    rightHtml += `<div class="text-line"></div>`;
                    i++;
                } else {
                    // 两行确实不同，使用字符级差异高亮
                    const charDiff = highlightCharsDiff(l, r);
                    leftHtml += `<div class="text-line ${l ? 'diff-removed' : ''}">${charDiff.old}</div>`;
                    rightHtml += `<div class="text-line ${r ? 'diff-added' : ''}">${charDiff.new}</div>`;
                    i++;
                    j++;
                }
            }
        }

        return { leftHtml, rightHtml };
    }

    async function compareJSON(leftRaw, rightRaw) {
        const sort = optJsonSort.checked;
        const format = optJsonFormat.checked;

        // 解析JSON时不排序，因为alignJSON会处理排序
        let leftParsed = parseJSON(leftRaw, false);
        let rightParsed = parseJSON(rightRaw, false);

        let leftFormatted = leftRaw;
        let rightFormatted = rightRaw;

        if ((sort || format) && leftParsed && rightParsed) {
            // 对齐左右两侧的JSON对象，确保相同字段在同一行
            const aligned = alignJSON(leftParsed, rightParsed);
            leftFormatted = formatAlignedJSON(aligned.left);
            rightFormatted = formatAlignedJSON(aligned.right);
        } else if ((sort || format) && leftParsed) {
            leftFormatted = formatJSON(leftRaw, sort);
        } else if ((sort || format) && rightParsed) {
            rightFormatted = formatJSON(rightRaw, sort);
        }

        const diffResult = highlightJSONDiff(leftFormatted, rightFormatted);

        leftTextEditor.innerHTML = `<div id="leftTextEditable" class="editable-div" contenteditable="false" ondblclick="resetEditorsToTextarea()">${diffResult.leftHtml}</div>`;
        rightTextEditor.innerHTML = `<div id="rightTextEditable" class="editable-div" contenteditable="false" ondblclick="resetEditorsToTextarea()">${diffResult.rightHtml}</div>`;
        isReplaced.left = true;
        isReplaced.right = true;
        backToEditBtn.style.display = 'inline-flex';
        // 重新绑定滚动事件
        bindScrollEvents();

        const leftLines = leftFormatted.split('\n');
        const rightLines = rightFormatted.split('\n');
        const result = await compareLine(leftLines, rightLines);

        return result;
    }

    function delayFrame() {
        return new Promise(resolve => requestAnimationFrame(resolve));
    }

    async function compareSet(aItems, bItems) {
        const aMap = toCountMap(aItems);
        const bMap = toCountMap(bItems);
        const sameMap = new Map();
        const aMoreMap = new Map();
        const bMoreMap = new Map();

        const keys = [...new Set([...aMap.keys(), ...bMap.keys()])];
        const chunk = 1200;
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const aCount = aMap.get(key) || 0;
            const bCount = bMap.get(key) || 0;
            const common = Math.min(aCount, bCount);
            if (common > 0) sameMap.set(key, common);
            if (aCount > bCount) aMoreMap.set(key, aCount - bCount);
            if (bCount > aCount) bMoreMap.set(key, bCount - aCount);

            if (i % chunk === 0) {
                const p = Math.min(99, Math.floor(i / Math.max(keys.length, 1) * 100));
                setProgress(`比较中... ${p}%`);
                await delayFrame();
            }
        }

        return {
            aMore: mapToExpandedArray(aMoreMap),
            bMore: mapToExpandedArray(bMoreMap),
            same: mapToExpandedArray(sameMap)
        };
    }

    async function compareLine(aItems, bItems) {
        const max = Math.max(aItems.length, bItems.length);
        const result = { aMore: [], bMore: [], same: [] };
        const chunk = 1200;

        for (let i = 0; i < max; i++) {
            const a = aItems[i] || '';
            const b = bItems[i] || '';
            if (a === b) {
                if (a !== '' || b !== '') result.same.push(a);
                continue;
            }
            if (a) result.aMore.push(a);
            if (b) result.bMore.push(b);

            if (i % chunk === 0) {
                const p = Math.min(99, Math.floor(i / Math.max(max, 1) * 100));
                setProgress(`比较中... ${p}%`);
                await delayFrame();
            }
        }

        return result;
    }

    function updateSummary(aTotal, bTotal, sameCount, aMoreCountValue, bMoreCountValue) {
        metricATotal.textContent = String(aTotal);
        metricBTotal.textContent = String(bTotal);
        metricSame.textContent = String(sameCount);
        metricAMore.textContent = String(aMoreCountValue);
        metricBMore.textContent = String(bMoreCountValue);

        const denom = Math.max(aTotal, bTotal, 1);
        const similarity = ((sameCount / denom) * 100).toFixed(2);
        metricSimilarity.textContent = `${similarity}%`;
    }

    function updateCards() {
        ['aMore', 'bMore', 'same'].forEach(group => {
            const allItems = state.result[group];
            groupMeta[group].count.textContent = `${allItems.length} 条`;
            virtualLists[group].setItems(allItems);
        });
        applySearch();
    }

    function applySearch() {
        state.search = searchInput.value.trim();

        // 搜索比较结果
        ['aMore', 'bMore', 'same'].forEach(group => {
            if (state.result[group].length) {
                virtualLists[group].applyFilter(state.search);
            }
        });

        // 搜索左右编辑器内容
        const searchTerm = state.search;

        // 处理编辑模式（textarea）
        if (!isReplaced.left && leftText) {
            if (searchTerm) {
                highlightTextInElement(leftText, searchTerm);
            } else {
                // 清除高亮，恢复原始内容
                if (leftText.dataset.originalContent) {
                    delete leftText.dataset.originalContent;
                }
            }
        }
        if (!isReplaced.right && rightText) {
            if (searchTerm) {
                highlightTextInElement(rightText, searchTerm);
            } else {
                // 清除高亮，恢复原始内容
                if (rightText.dataset.originalContent) {
                    delete rightText.dataset.originalContent;
                }
            }
        }

        // 处理对比模式（editable-div）
        const leftEditable = document.getElementById('leftTextEditable');
        const rightEditable = document.getElementById('rightTextEditable');

        if (leftEditable) {
            if (searchTerm) {
                highlightTextInElement(leftEditable, searchTerm);
            } else {
                // 清除高亮，恢复原始内容
                const lines = leftEditable.querySelectorAll('.text-line');
                lines.forEach(line => {
                    if (line.dataset.originalHtml) {
                        line.innerHTML = line.dataset.originalHtml;
                        delete line.dataset.originalHtml;
                    }
                });
            }
        }
        if (rightEditable) {
            if (searchTerm) {
                highlightTextInElement(rightEditable, searchTerm);
            } else {
                // 清除高亮，恢复原始内容
                const lines = rightEditable.querySelectorAll('.text-line');
                lines.forEach(line => {
                    if (line.dataset.originalHtml) {
                        line.innerHTML = line.dataset.originalHtml;
                        delete line.dataset.originalHtml;
                    }
                });
            }
        }
    }

    function highlightTextInElement(element, searchTerm) {
        if (!element || !searchTerm) return;

        // 检查元素是否是逐行比较的结果容器
        if (element.id === 'leftTextEditable' || element.id === 'rightTextEditable') {
            // 对于逐行比较的结果，我们需要保留原始的行结构
            // 遍历所有行元素并单独高亮
            const lines = element.querySelectorAll('.text-line');
            lines.forEach(line => {
                if (!line.dataset.originalHtml) {
                    line.dataset.originalHtml = line.innerHTML;
                }

                if (searchTerm) {
                    // 保存原始的HTML标签
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = line.dataset.originalHtml;
                    
                    // 递归处理所有文本节点
                    function highlightTextNodes(node) {
                        if (node.nodeType === 3) { // 文本节点
                            const text = node.textContent;
                            const escapedSearchTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                            const regex = new RegExp(`(${escapedSearchTerm})`, 'gi');
                            const highlightedText = text.replace(regex, '<mark>$1</mark>');
                            if (highlightedText !== text) {
                                const span = document.createElement('span');
                                span.innerHTML = highlightedText;
                                node.parentNode.replaceChild(span, node);
                            }
                        } else if (node.nodeType === 1 && node.tagName !== 'MARK') { // 元素节点且不是mark标签
                            for (let i = 0; i < node.childNodes.length; i++) {
                                highlightTextNodes(node.childNodes[i]);
                            }
                        }
                    }
                    
                    // 应用高亮
                    highlightTextNodes(tempDiv);
                    
                    // 更新行内容
                    line.innerHTML = tempDiv.innerHTML;
                } else {
                    // 清除高亮，恢复原始内容
                    line.innerHTML = line.dataset.originalHtml;
                }
            });
        } else {
            // 对于其他元素，使用普通的高亮方法
            if (!element.dataset.originalContent) {
                element.dataset.originalContent = element.textContent;
            }

            let content = element.dataset.originalContent;

            if (searchTerm) {
                const escapedSearchTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(`(${escapedSearchTerm})`, 'gi');
                content = content.replace(regex, '<mark>$1</mark>');
            }

            // 对于textarea，我们不能直接修改innerHTML，需要使用其他方法
            // 对于div，我们可以直接修改innerHTML
            if (element.tagName === 'TEXTAREA') {
                // 注意：textarea不支持innerHTML，这里我们需要使用其他方法
                // 由于textarea的限制，我们暂时只支持搜索结果的高亮
            } else {
                element.innerHTML = content;
            }
        }
    }

    function applyCardFilter() {
        const cards = Array.from(document.querySelectorAll('.result-card'));
        cards.forEach(card => {
            const group = card.getAttribute('data-group');
            card.classList.toggle('hidden', state.filter !== 'all' && state.filter !== group);
        });
    }

    function downloadFile(name, content, type) {
        const blob = new Blob([content], { type });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = name;
        a.click();
        URL.revokeObjectURL(url);
    }

    function toCsv(items) {
        const escaped = items.map(v => `"${v.replace(/"/g, '""')}"`);
        return `value\n${escaped.join('\n')}`;
    }

    async function copyGroup(group) {
        const text = state.result[group].join('\n');
        if (!text) return;
        try {
            await navigator.clipboard.writeText(text);
            setProgress(`已复制 ${groupMeta[group].count.textContent}`);
        } catch {
            setProgress('复制失败，请检查浏览器权限');
        }
    }

    async function compare() {
        const leftRaw = leftText.value;
        const rightRaw = rightText.value;

        if (!leftRaw && !rightRaw) {
            setProgress('请输入待比较内容');
            return;
        }

        setProgress('准备比较...');

        let result;
        let leftItems, rightItems;

        if (state.mode === 'json') {
            result = await compareJSON(leftRaw, rightRaw);
            leftItems = result.aMore.concat(result.same);
            rightItems = result.bMore.concat(result.same);
            resultSection.style.display = 'none';
        } else if (state.mode === 'set') {
            resetEditorsToTextarea();
            leftItems = tokenize(leftRaw);
            rightItems = tokenize(rightRaw);
            result = await compareSet(leftItems, rightItems);
            resultSection.style.display = 'grid';
        } else {
            // 使用普通的逐行比较
            resetEditorsToTextarea();
            leftItems = tokenize(leftRaw);
            rightItems = tokenize(rightRaw);
            
            // 如果启用了排序，对原始文本也进行排序处理后再渲染
            let leftRenderLines = leftRaw.split(/\r?\n/);
            let rightRenderLines = rightRaw.split(/\r?\n/);
            
            if (optSort.checked) {
                // 对原始行进行标准化处理，然后排序
                const leftNormalized = leftRenderLines.map(normalizeToken).filter(optEmpty.checked ? Boolean : () => true);
                const rightNormalized = rightRenderLines.map(normalizeToken).filter(optEmpty.checked ? Boolean : () => true);
                
                // 排序后重新构建渲染行
                leftRenderLines = leftNormalized.sort();
                rightRenderLines = rightNormalized.sort();
            }
            
            renderDiffPanels(leftRenderLines, rightRenderLines);
            result = await compareLine(leftItems, rightItems);
            resultSection.style.display = 'none';
        }

        state.result = result;

        updateSummary(
            leftItems.length,
            rightItems.length,
            result.same.length,
            result.aMore.length,
            result.bMore.length
        );
        updateCards();
        setSummaryVisible(true);

        let modeText = '集合比较';
        if (state.mode === 'line') modeText = '逐行比较';
        if (state.mode === 'json') modeText = 'JSON比较';
        setProgress(`比较完成：${modeText}`);
        syncLineNumbers();
    }

    function resetResults() {
        state.result = { aMore: [], bMore: [], same: [] };
        metricATotal.textContent = '0';
        metricBTotal.textContent = '0';
        metricSame.textContent = '0';
        metricAMore.textContent = '0';
        metricBMore.textContent = '0';
        metricSimilarity.textContent = '0%';

        ['aMore', 'bMore', 'same'].forEach(group => {
            groupMeta[group].count.textContent = '0 条';
            virtualLists[group].setItems([]);
        });
    }

    function onModeChange(mode) {
        state.mode = mode;
        modeButtons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });
        backToEditBtn.style.display = (mode === 'line' || mode === 'json') && isReplaced.left ? 'inline-flex' : 'none';
        jsonOptions.style.display = mode === 'json' ? 'flex' : 'none';

        // 显示/隐藏文本处理选项
        const textOptionsElements = document.querySelectorAll('.text-options');
        const isJsonMode = mode === 'json';
        textOptionsElements.forEach(el => {
            el.style.display = isJsonMode ? 'none' : 'flex';
        });

        if (mode === 'set') {
            resultSection.style.display = 'grid';
        } else {
            resultSection.style.display = 'none';
        }
    }

    function wireDrop(panel, textarea) {
        panel.addEventListener('dragover', (e) => {
            e.preventDefault();
            panel.classList.add('drag-over');
        });
        panel.addEventListener('dragleave', () => panel.classList.remove('drag-over'));
        panel.addEventListener('drop', (e) => {
            e.preventDefault();
            panel.classList.remove('drag-over');
            const file = e.dataTransfer.files && e.dataTransfer.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
                textarea.value = String(reader.result || '');
                syncLineNumbers();
                if (delimiterSelect.value === 'auto') {
                    delimiterSelect.value = detectDelimiter(textarea.value);
                }
            };
            reader.readAsText(file);
        });
    }

    function handlePasteAutoDetect() {
        const handler = (e) => {
            const txt = e.clipboardData?.getData('text/plain') || '';
            if (!txt) return;
            const detected = detectDelimiter(txt);
            if (delimiterSelect.value === 'auto') {
                setProgress(`已自动识别分隔符：${detected === 'newline' ? '换行' : detected === 'tab' ? '制表符' : '逗号'}`);
            } else {
                delimiterSelect.value = detected;
            }
        };
        leftText.addEventListener('paste', handler);
        rightText.addEventListener('paste', handler);
    }

    resultSection.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-action]');
        if (!btn) return;
        const action = btn.dataset.action;
        const group = btn.dataset.group;

        if (action === 'copy') copyGroup(group);
        if (action === 'txt') downloadFile(`${group}.txt`, state.result[group].join('\n'), 'text/plain;charset=utf-8');
        if (action === 'csv') downloadFile(`${group}.csv`, toCsv(state.result[group]), 'text/csv;charset=utf-8');
        if (action === 'focus') {
            state.filter = state.filter === group ? 'all' : group;
            applyCardFilter();
            btn.textContent = state.filter === group ? '显示全部' : '仅看';
            Array.from(document.querySelectorAll(`button[data-action="focus"]`)).forEach(other => {
                if (other.dataset.group !== group) other.textContent = '仅看';
            });
        }
    });

    compareBtn.addEventListener('click', compare);

    clearBtn.addEventListener('click', () => {
        resetEditorsToTextarea();
        leftText.value = '';
        rightText.value = '';
        state.filter = 'all';
        applyCardFilter();
        Array.from(document.querySelectorAll('button[data-action="focus"]')).forEach(btn => btn.textContent = '仅看');
        resetResults();
        syncLineNumbers();
        setProgress('');
        setSummaryVisible(false);
        backToEditBtn.style.display = 'none';
    });

    backToEditBtn.addEventListener('click', () => {
        resetEditorsToTextarea();
        syncLineNumbers();
        backToEditBtn.style.display = 'none';
    });

    let isSyncing = false;
    let scrollTimeout;

    // 节流函数
    function throttle(func, limit) {
        let inThrottle;
        return function() {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
                func.apply(context, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }

    function bindScrollEvents() {
        // 滚动同步函数
        function syncScroll(source, targetEditor, targetTextarea, targetLineNumbers) {
            if (!isSyncing) {
                isSyncing = true;
                
                // 使用requestAnimationFrame优化滚动同步
                requestAnimationFrame(() => {
                    targetEditor.scrollTop = source.scrollTop;
                    targetLineNumbers.scrollTop = source.scrollTop;
                    if (targetTextarea) {
                        targetTextarea.scrollTop = source.scrollTop;
                    }
                    isSyncing = false;
                });
            }
        }

        // 绑定编辑器容器的滚动事件（用于差异视图）
        leftTextEditor.onscroll = throttle(() => {
            leftLineNumbers.scrollTop = leftTextEditor.scrollTop;
            syncScroll(leftTextEditor, rightTextEditor, rightText, rightLineNumbers);
        }, 16); // 约60fps

        rightTextEditor.onscroll = throttle(() => {
            rightLineNumbers.scrollTop = rightTextEditor.scrollTop;
            syncScroll(rightTextEditor, leftTextEditor, leftText, leftLineNumbers);
        }, 16);

        // 绑定textarea的滚动事件（用于集合比较模式）
        if (leftText) {
            leftText.onscroll = throttle(() => {
                leftLineNumbers.scrollTop = leftText.scrollTop;
                syncScroll(leftText, rightTextEditor, rightText, rightLineNumbers);
            }, 16);
        }

        if (rightText) {
            rightText.onscroll = throttle(() => {
                rightLineNumbers.scrollTop = rightText.scrollTop;
                syncScroll(rightText, leftTextEditor, leftText, leftLineNumbers);
            }, 16);
        }
    }

    // 初始绑定滚动事件
    bindScrollEvents();

    leftText.addEventListener('input', syncLineNumbers);
    rightText.addEventListener('input', syncLineNumbers);
    searchInput.addEventListener('input', applySearch);

    modeButtons.forEach(btn => {
        btn.addEventListener('click', () => onModeChange(btn.dataset.mode));
    });

    parseMode.addEventListener('change', () => {
        delimiterSelect.disabled = parseMode.value === 'line';
    });

    // 添加键盘快捷键支持
    document.addEventListener('keydown', (e) => {
        // ESC键返回编辑模式
        if (e.key === 'Escape') {
            if (isReplaced.left || isReplaced.right) {
                resetEditorsToTextarea();
                backToEditBtn.style.display = 'none';
            }
        }
    });

    wireDrop(leftPanel, leftText);
    wireDrop(rightPanel, rightText);
    handlePasteAutoDetect();

    window.onload = () => {
        delimiterSelect.disabled = parseMode.value === 'line';
        resetResults();
        syncLineNumbers();
        setSummaryVisible(false);
        // 确保默认模式为逐行比较
        onModeChange('line');
    };
</script>
</body>
</html>
